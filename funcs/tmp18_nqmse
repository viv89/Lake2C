# -*- coding: utf-8 -*-
"""
Created on Tue Apr  5 15:04:16 2022

@author: vija
"""
import numpy as np
import pandas as pd
from pvlib.iotools import read_epw
from pvlib.solarposition import get_solarposition
import glob
import yaml
from yaml.loader import SafeLoader
import seaborn as sns
import matplotlib.pyplot as plt

def read_lake_props(lake_fname):
    
    lake_data  = eval(open(lake_fname).read())
    return lake_data

def read_data(weather_file, profiles_file):
    
    # Initialize dataframe
    data = pd.DataFrame()
    
    # Read epw data
    weather_data = read_epw(weather_file, coerce_year = None)
    info = weather_data[1]
    
    data['month'] = weather_data[0]['month'].values
    data['day']   = weather_data[0]['day'].values
    data['hour']  = weather_data[0]['hour'].values
    
    data['Te']  = weather_data[0]['temp_air'].values
    data['RHe'] = weather_data[0]['relative_humidity'].values
    data['ghi'] = weather_data[0]['ghi'].values
    data['dni'] = weather_data[0]['dni'].values
    data['dhi'] = weather_data[0]['dhi'].values            #
    data['v_wind'] = weather_data[0]['wind_speed'].values  # m/s
    data['sky_cover'] = weather_data[0]['total_sky_cover'].values/10 # 0 = clear sky, 1 = fully covered
           
    date_range = pd.date_range(start='1/1/2018', periods=8760, freq='H')
    data.index = date_range
    
    solardata = get_solarposition(data.index, 
                                  info['latitude'], 
                                  info['longitude'], 
                                  altitude=info['altitude'], 
                                  pressure=None, method='nrel_numpy', temperature=12)
    data['solarpos_eq'] = np.multiply(solardata['elevation'].values,data['ghi'].values)
    data_daily = data.resample('D').mean()
    data_daily['solarpos_eq'] = np.divide(data_daily['solarpos_eq'].values,data_daily['ghi'].values)
    # Note that GHI, DNI AND DHI are in (W/m2), energy demands are in W
    del data_daily['hour']  
    
    # Read demand for space heating, cooling (10% of the total demand within 3 km from lake perimeter)
    demand = pd.read_excel(profiles_file,sheet_name = 0, header = 0)
    data_daily['cooling_demand'] = demand['cooling_kW'].values/10   
    data_daily['heating_demand'] = demand['heating_kW'].values/10

    return data_daily, info

    

def read_parameters(weather_file, hubs_file):
    
    # Read epw data
    weather_data = read_epw(weather_file, coerce_year = None)
    
    # Set location (for radiation processing) from epw
    loc_settings = {'city': weather_data[1]['city'], 
                    'lat' : weather_data[1]['latitude'], 
                    'lon' : weather_data[1]['longitude'],  
                    'alt' : weather_data[1]['altitude'], 
                    'tz'  :'Europe/Rome'}  #manually set (otherwise  weather_data[1]['TZ'])
    
    files = glob.glob('input/*.yaml')
    params = dict()
    for file in files:
    
        # Open the file and load the file
        with open(file) as f:
            fname = file.split('\\')[1].split('.')[0]
            params[fname] = yaml.load(f, Loader=SafeLoader)
    
    params['loc_settings'] = loc_settings
    
    params['branches'] = pd.read_excel(hubs_file, sheet_name = 0, 
                                       header = 0, index_col=0)
    params['nodes']    = pd.read_excel(hubs_file, sheet_name = 1, 
                                       header = 0, index_col=0)
        
    return params



def run_validation(lake_name, simout):
    
    validation_file = 'input/validation/' + lake_name +'.xlsx'
    if lake_name == 'greifensee':
        # read temperatures for validation file
        vdata = pd.read_excel(validation_file, sheet_name = 3, header = 0, 
                              names = ['time','1m','15m','30m'])
    elif lake_name == 'geneva':
        vdata = pd.read_excel(validation_file, sheet_name = 4, header = 0, 
                              names = ['time','2m','20m','50m','150m'])       
    elif lake_name == 'feeagh':
        vdata = pd.read_excel(validation_file, sheet_name = 0, header = 0, 
                              index_col = 0)
    
    if lake_name == 'feeagh':
        date_range = pd.date_range(start='1/1/2019', periods=366, freq='1D')
        vdata.index = date_range   
        vdata_daily = vdata
    else:
        date_range = pd.date_range(start='1/1/2019', periods=2921, freq='3H')
        vdata.index = date_range
        vdata_daily = vdata.resample('D').mean()
    
    vdata_daily = vdata_daily[:len(simout.index)]

    # compare outputs
    vdata_daily['Tw_e']  = simout['Tw_e'].values
    # vdata_daily['Tw_t']  = simout['Tw_t'].values
    vdata_daily['Tw_h']  = simout['Tw_h'].values
    
    # Verify output in postprocessing (should be close to zero after n_years)
    simout['deltaQ_epi'] = -(simout['Q_ev'] +  simout['Q_conv'] + simout['Q_lw'] + simout['Q_diff']) + (simout['Q_sw'] - simout['Q_sw_tr'])
    # simout['deltaQ_trn'] = simout['Q_diff_b1'] 
    #
    if lake_name == 'geneva':
        errors = {'annual_balance_epi' : simout['deltaQ_epi'].sum(), 
                  'error_surf_avg' : np.mean(vdata_daily.Tw_e.values - vdata_daily['2m'].values),
                  'error_surf_max' : np.max(vdata_daily.Tw_e.values - vdata_daily['2m'].values),
                  'error_bott_avg' : np.mean(vdata_daily.Tw_h.values - vdata_daily['150m'].values),
                  'error_bott_max' : np.min(vdata_daily.Tw_h.values - vdata_daily['150m'].values)}
    elif lake_name == 'greifensee':    
        errors = {'annual_balance_epi' : simout['deltaQ_epi'].sum(), 
                  'error_surf_avg' : np.mean(vdata_daily.Tw_e.values - vdata_daily['1m'].values),
                  'error_surf_max' : np.max(vdata_daily.Tw_e.values - vdata_daily['1m'].values),
                  'error_bott_avg' : np.mean(vdata_daily.Tw_h.values - vdata_daily['30m'].values),
                  'error_bott_max' : np.min(vdata_daily.Tw_h.values - vdata_daily['30m'].values)}
    elif lake_name == 'feeagh':
        errors = {'annual_balance_epi' : simout['deltaQ_epi'].sum(), 
                  'error_surf_avg' : np.mean(vdata_daily.Tw_e.values - vdata_daily[-1.0].values),
                  'error_surf_max' : np.max(vdata_daily.Tw_e.values - vdata_daily[-1.0].values),
                  'error_bott_avg' : np.mean(vdata_daily.Tw_h.values - vdata_daily[-30.0].values),
                  'error_bott_max' : np.min(vdata_daily.Tw_h.values - vdata_daily[-30.0].values)}

    return vdata_daily, errors

def heatmap(lake_name, simout):
    pldata = simout[['Tw_e','Tw_h','Tw_h','Tw_h','Tw_h']].transpose()
    ax = sns.heatmap(pldata, xticklabels=30, yticklabels=False)
    plt.title(lake_name)
    # plt.savefig('output/figure_2c_heatmap_corr_'+lake_name+'.png')
    return

def plot_profiles(lake_name, vdata):
    fig, ax = plt.subplots()
    ax.plot(vdata.index, vdata['Tw_e'], 'r', linewidth=1.0, label = 'Model surface layer')
    # ax.plot(vdata.index, vdata['Tw_t'], 'g', linewidth=1.0, label = 'Model transition layer')
    ax.plot(vdata.index, vdata['Tw_h'], 'b', linewidth=1.0, label = 'Model bottom layer')
    if lake_name == 'geneva':
        ax.plot(vdata.index, vdata['2m'], 'r:', linewidth=1.5, label = 'Measured 2m')
        ax.plot(vdata.index, vdata['20m'], 'g:', linewidth=1.5, label = 'Measured 20m')
        ax.plot(vdata.index, vdata['50m'], 'b:', linewidth=1.5, label = 'Measured 50m')
    elif lake_name == 'greifensee':
        ax.plot(vdata.index, vdata['1m'], 'r:', linewidth=1.5, label = 'Measured 1m')
        ax.plot(vdata.index, vdata['15m'], 'g:', linewidth=1.5, label = 'Measured 15m')
        ax.plot(vdata.index, vdata['30m'], 'b:', linewidth=1.5, label = 'Measured 30m')
    elif lake_name == 'feeagh':
        ax.plot(vdata.index, vdata[-1.0], 'r:', linewidth=1.5, label = 'Simstrat 1m')
        ax.plot(vdata.index, vdata[-15.0], 'g:', linewidth=1.5, label = 'Simstrat 15m')
        ax.plot(vdata.index, vdata[-30.0], 'b:', linewidth=1.5, label = 'Simstrat 30m')
    # ax.plot(vdata.index, -simout['ghi']/20, 'k', linewidth=1.0, label = 'ghi')
    # ax.plot(vdata.index, simout['Tw_e']-simout['Te'], 'b', linewidth=1.0, label = 'Te')
    ax.legend()
    plt.ylabel('Temperature (Â°C)')
    plt.grid(True)
    # plt.show()
    plt.title(lake_name)
    # plt.savefig('output/figure_2c_profiles_corr_'+lake_name+'.png')
    return
    
    


    